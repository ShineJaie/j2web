Java Web 开发中是上下文的保存。java.lang.ThreadLocal 可以存储属于当前 thread 的变量，
而 servlet 的一次请求正好满足这种情况(包括后面业务代码的调用)，所以可以把需要的东西放在 ThreadLocal 实例中。

早在 JDK 1.2的版本中就提供 java.lang.ThreadLocal，ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。
使用这个工具类可以很简洁地编写出优美的多线程程序。ThreadLocal 很容易让人望文生义，想当然地认为是一个“本地线程”。
其实，ThreadLocal 并不是一个 Thread，而是 Thread 的局部变量，也许把它命名为 ThreadLocalVariable 更容易让人理解一些。
当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，
所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。

ThreadLocal的接口方法

ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：

    * void set(Object value)

设置当前线程的线程局部变量的值。

    * public Object get()

该方法返回当前线程所对应的线程局部变量。

    * public void remove()

将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。
需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，
所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。

    * protected Object initialValue()

返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。
这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。
ThreadLocal中的缺省实现直接返回一个null。
值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal<T>。
API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。

Thread同步机制的比较

ThreadLocal和线程同步机制(synchronized)相比有什么优势呢？
ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。

在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。
这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，
什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。

而ThreadLocal则从另一个角度来解决多线程的并发访问。
ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。
因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。
ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，
而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，
而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

总结：
ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。
在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。